<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>听话，叫叔叔！</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="听话，叫叔叔！">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="听话，叫叔叔！">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="听话，叫叔叔！">
  
    <link rel="alternate" href="/atom.xml" title="听话，叫叔叔！" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">听话，叫叔叔！</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Zoeken"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-关于vue" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/12/关于vue/" class="article-date">
  <time datetime="2017-06-12T15:40:12.954Z" itemprop="datePublished">2017-06-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/12/关于vue/">跟vue有关</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="vue介绍："><a href="#vue介绍：" class="headerlink" title="vue介绍："></a>vue介绍：</h3><ul>
<li>Vue.js是构建数据驱动的 web 界面的库,而不是一个全能框架—它只 聚焦于视图层，特点：<ul>
<li>1.响应的数据绑定 每当修改了数据，DOM 便相应地更新。这样我们应用中的逻辑就 几乎都是直接修改数据了，不必与 DOM 更新搅在一起。这让我 们的代码更容易 撰写、理解与维护</li>
<li>2.组件系统 让我们可以用独立可复用的小组件来构建大型应用</li>
<li>3.特性 简洁 数据驱动 组件化 轻量快速 模块友好</li>
<li>4.Vue.js 不支持 IE8 及其以下版本<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3></li>
</ul>
</li>
<li>安装前初始化package.json,主要用来描述自己的项目，记录安装过的文件有哪些,在当前文件下生成json,名字不能叫要安装的文件</li>
<li>使用cdn<ul>
<li><a href="http://cdn.jsdelivr.net/vue/1.0.26/vue.min.js" target="_blank" rel="external">http://cdn.jsdelivr.net/vue/1.0.26/vue.min.js</a></li>
</ul>
</li>
<li>通过npm安装<ul>
<li>注意：–save或者-S代表项目依赖 –save-dev或者-D开发依赖</li>
<li>npm init -y</li>
<li>$ npm install vue</li>
</ul>
</li>
<li>通过bower安装<ul>
<li>$ bower install vue</li>
</ul>
</li>
<li>安装后默认会生成node_modules文件夹<ul>
<li>上传到git上node_modules是忽略掉的，拉下代码后 需要重新npm install 安装依赖<h3 id="api"><a href="#api" class="headerlink" title="api"></a>api</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">v-text &#123;&#123;&#125;&#125;</div><div class="line">v-html</div><div class="line">v-model </div><div class="line">v-once</div><div class="line">v-on:click -&gt; @click</div><div class="line">v-for</div><div class="line">v-if/v-show</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="修饰符-click-xxx"><a href="#修饰符-click-xxx" class="headerlink" title="修饰符 @click.xxx"></a>修饰符 @click.xxx</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.stop</div><div class="line">.capture</div><div class="line">.keyCode</div><div class="line">.once</div><div class="line">.prevent</div><div class="line">.self</div></pre></td></tr></table></figure>
<h3 id="vue用法"><a href="#vue用法" class="headerlink" title="vue用法"></a>vue用法</h3><ul>
<li><p>hello world</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;app&quot;&gt;</div><div class="line">    &#123;&#123;message&#125;&#125;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script&gt;</div><div class="line">    var vm = new Vue(&#123;</div><div class="line">        el:&apos;.app&apos;,</div><div class="line">        data:&#123;//小胡子语法</div><div class="line">            message:&apos;hello world&apos;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>双向数据绑定v-model</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;app&quot;&gt;</div><div class="line">    &#123;&#123;message&#125;&#125;</div><div class="line">  + &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>绑定表达式 </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&#123;&#123;&#125;&#125;将模型的数据取出显示到页面上(支持三元表达式)</div><div class="line"></div><div class="line">&#123;&#123;message?message:&apos;init data&apos;&#125;&#125;</div><div class="line"></div><div class="line">&#123;&#123;&#123;&#125;&#125;&#125;将html类型的数据正常绑定到页面上</div><div class="line">    &#123;&#123;*message&#125;&#125;</div><div class="line"></div><div class="line">&#123;&#123;&#123;&#125;&#125;&#125;将html类型的数据正常绑定到页面上</div><div class="line">     &lt;div class=&quot;app&quot;&gt;</div><div class="line">         &#123;&#123;&#123;message&#125;&#125;&#125;</div><div class="line">     &lt;/div&gt;</div><div class="line">     &lt;script&gt;</div><div class="line">         var vm = new Vue(&#123;</div><div class="line">             el:&apos;.app&apos;,</div><div class="line">             data:&#123;</div><div class="line">                 message:&apos;&lt;h1&gt;hello world&lt;/h1&gt;&apos;</div><div class="line">             &#125;</div><div class="line">         &#125;);</div><div class="line">     &lt;/script&gt;</div></pre></td></tr></table></figure>
<ul>
<li><p>Vue的实例</p>
<ul>
<li>一个 Vue 实例其实正是一个 MVVM 模式中所描述的 ViewModel(实例上的data属性绑定的数据和原数据指定的是同一内存空间)<ul>
<li>model</li>
<li>view </li>
<li>viewModel</li>
</ul>
</li>
<li>MVC<ul>
<li>model  数据</li>
<li>view   视图</li>
<li>controller 控制器<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var message  = &#123;</div><div class="line">    name:&apos;hello&apos;</div><div class="line">&#125;;</div><div class="line">var vm = new Vue(&#123;</div><div class="line">    el:&apos;.app&apos;,</div><div class="line">    data:&#123;</div><div class="line">        message:message</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">alert(vm.message == message);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>修改数据属性刷新视图 </p>
<ul>
<li>注意：<ul>
<li>不能将原数据指向新的数据，否则不能刷新视图</li>
<li>实例创建后不能设置以前没有的属性，无法映射到视图</li>
<li>Vue.set/vm.$set可以给对象添加属性</li>
</ul>
</li>
</ul>
</li>
<li><p>实例上的属性和方法</p>
<ul>
<li>Vue通过$暴露实例上的属性和方法</li>
<li>$el ：获取当前绑定的元素</li>
<li>$data ：获取当前绑定的数据(更换data对象刷新视图，尽量不去更换)</li>
<li>$watch :监控模型的变化<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vm.$watch(&apos;message&apos;, function (newVal,oldVal) &#123;</div><div class="line">    console.log(newVal,oldVal);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li>方法名           用法</li>
<li>created     先实例化,在实例化后(检测el)</li>
<li>vm.$mount(‘#app’)    手动挂载实例</li>
<li>beforeCompile    开始编译之前</li>
<li>compiled    编译完成后</li>
<li>ready    插入文档后</li>
<li>vm.$destroy()    手动销毁实例</li>
<li>beforeDestroy    将要销毁</li>
<li>destroyed    销毁实例</li>
<li><p>生命周期的使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var vm = new Vue(&#123;</div><div class="line">    data:&#123;</div><div class="line">        hello:&apos;zfpx&apos;</div><div class="line">    &#125;,</div><div class="line">    created: function () &#123;alert(&apos;实例创建完成&apos;);&#125;,</div><div class="line">    beforeCompile: function () &#123;alert(&apos;开始编译前&apos;)&#125;,</div><div class="line">    compiled: function () &#123;alert(&apos;编译完成&apos;)&#125;,</div><div class="line">    ready: function () &#123;alert(&apos;准备好了&apos;)&#125;,</div><div class="line">    beforeDestroy: function () &#123;alert(&apos;准备销毁&apos;)&#125;,</div><div class="line">    destroyed: function () &#123;alert(&quot;销毁&quot;)&#125;</div><div class="line">&#125;);</div><div class="line">vm.$mount(&apos;#app&apos;);</div><div class="line">vm.$destroy();</div></pre></td></tr></table></figure>
<ul>
<li>属性的计算<ul>
<li>用于计算性属性(默认为属性的get方法)<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var vm = new Vue(&#123;</div><div class="line">    data:&#123;</div><div class="line">        name:&apos;zfpx&apos;</div><div class="line">    &#125;,</div><div class="line">    computed: &#123;</div><div class="line">        hello:&#123;</div><div class="line">            get: function () &#123;</div><div class="line">                return this.name+8;</div><div class="line">            &#125;,</div><div class="line">            set: function (val) &#123;</div><div class="line">                this.name = val</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/06/12/关于vue/" data-id="cj3ubyh0h0007ewuf9ta1i5ks" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-关于node" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/12/关于node/" class="article-date">
  <time datetime="2017-06-12T12:50:08.238Z" itemprop="datePublished">2017-06-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/12/关于node/">关于node.js</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/06/12/关于node/" data-id="cj3ubyh0h0003ewuf6c1ckah3" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-不支持低版本浏览器搜集" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/12/不支持低版本浏览器搜集/" class="article-date">
  <time datetime="2017-06-12T12:17:16.025Z" itemprop="datePublished">2017-06-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/12/不支持低版本浏览器搜集/">不支持的浏览器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-不支持-IE8-及其以下版本的"><a href="#1-不支持-IE8-及其以下版本的" class="headerlink" title="1.不支持 IE8 及其以下版本的"></a>1.不支持 IE8 及其以下版本的</h3><ul>
<li>Vue.js<h3 id="2-不支持-IE7-及其以下版本的"><a href="#2-不支持-IE7-及其以下版本的" class="headerlink" title="2.不支持 IE7 及其以下版本的"></a>2.不支持 IE7 及其以下版本的</h3></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/06/12/不支持低版本浏览器搜集/" data-id="cj3ubyh010002ewufwa51xffl" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-预解释&amp;闭包&amp;THIS&amp;面向对象" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/11/预解释&闭包&THIS&面向对象/" class="article-date">
  <time datetime="2017-06-11T12:41:44.948Z" itemprop="datePublished">2017-06-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/11/预解释&闭包&THIS&面向对象/">预解释&amp;闭包&amp;THIS&amp;面向对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="预解释和闭包"><a href="#预解释和闭包" class="headerlink" title="预解释和闭包"></a>预解释和闭包</h3><ul>
<li>数据类型:基本数据类型和引用数据类型的本质区别,数据类型检测</li>
<li>预解释:变量声明提升,函数声明和定义提升,在当前作用域中,JS代码从上到下执行之前,浏览器会把所有带var/function关键字的进行提前声明或者定义<ul>
<li>var和function有区别</li>
<li>作为值是不进行预解释的,return,function…,var fn=function(){}…</li>
<li>匿名函数不进行预解释: (function(){…})</li>
<li>不管条件是否成立,都要提前声明</li>
<li>已经声明过的不在重复进行声明,带var和function的声明的变量名相同属于声明同一个</li>
<li>在全局作用域下声明的函数和变量都是window的一个属性</li>
</ul>
</li>
<li><p>作用域和闭包</p>
<ul>
<li>堆内存的开辟赋值流程:开空间,存内容,地址赋值</li>
<li>栈内存的开辟(销毁)流程:形成私有作用域,形参赋值,预解释,代码执行,作用域的释放问题(只要当前私有作用域中某个东西被外面的其他内存占用了,私有作用域就不会销毁,没有被占用就自动销毁)</li>
<li>识别是否为私有变量:只有形参和在当前作用域中声明过的变量才是私有的,否则都是别人的</li>
<li>识别当前作用域的上级作用域:当前函数实在哪定义的,那么它对应的上级作用域就是谁(和在哪执行的没关系)<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num=<span class="number">10</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> num=<span class="number">100</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(num);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> f=fn();</div><div class="line">fn();</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> num=<span class="number">1000</span>;</div><div class="line">    fn();</div><div class="line">&#125;</div><div class="line">sum();</div><div class="line"><span class="string">``</span><span class="string">` </span></div><div class="line">- 作用域链:在当前作用域中需要使用一个变量,首先看是否为私有的,不是找上级作用域,如果也不是上级私有的,则继续向上查找,一直到window为止</div><div class="line">`<span class="string">``</span>JavaScript</div><div class="line"><span class="keyword">var</span> a=<span class="number">100</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(a);<span class="comment">//-&gt;100</span></div><div class="line">    a=<span class="number">200</span>;</div><div class="line">    <span class="built_in">console</span>.log(b);<span class="comment">//-&gt;报错:b is not defined</span></div><div class="line">    b=<span class="number">100</span>;<span class="comment">//-&gt;window.b=100</span></div><div class="line">&#125;</div><div class="line">fn();</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>小细节</p>
<ul>
<li><p>“i++”和”++i”的区别:加不加括号都是按照之前的机制运算,加括只是保证语法正确,不是改变优先级</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i=<span class="number">5</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="number">6</span>+(i++)+(++i)+<span class="number">3</span><span class="number">-5</span>+(++i)<span class="number">-6</span>+(i++)+(--i)+(i--)+<span class="number">5</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>arguments,arguments.callee,arguments.callee.caller,argument在非严格模式下和形参的映射关系,以及严格模式下和非严格模式下对于arguments的区别</p>
</li>
<li><p>“||”和”&amp;&amp;”</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a,b</span>)</span>&#123;</div><div class="line">    <span class="comment">//-&gt;为形参设置默认值,如果没有传递值的话,让默认值都为零(以下两种方式都可以,第一种严谨,第二种简单)</span></div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> a===<span class="string">"undefined"</span>)&#123;</div><div class="line">        a=<span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    b=b||<span class="number">0</span>;</div><div class="line">    <span class="built_in">console</span>.log(a+b);</div><div class="line">&#125;</div><div class="line">fn(<span class="number">10</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>匿名函数:函数表达式,自执行函数</p>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3></li>
</ul>
</li>
<li>this<ul>
<li>this是谁和在哪儿定义的以及在哪执行的没有半毛钱关系,主要都是按照以下几条来分析即可:</li>
<li>自执行函数中的this是window(非严格模式下如此,严格模式下是undefined)</li>
<li>给元素的某个事件绑定方法,当事件触发方法执行,此时方法中的htis是当前元素(DOM2级事件绑定在IE6-8下,方法中的this是window)</li>
<li>函数执行,看函数前面是否有点”.”,有”.”点前面是谁this就是谁,没有的话,非严格模式下是window,严格模式下是undefined</li>
<li>构造函数模式中,函数体中出现的this.xxx=xxx中的this是当前类的一个实例,此操作是给当前实例增加私有的属性</li>
<li>使用call/apply/bind可以改变函数中this的指向,也是五条规律中最霸道的<ul>
<li>call:把函数中的this改变,然后让函数执行,给函数传递的参数值依然是一个个的传递的</li>
<li>apply:和call作用一样,只不过传递给函数的参数是放在一个数组中传递进去的,但是也相当于在一个个的给函数赋值</li>
<li>bind:预先把this指向改变,但是函数并没有执行,属于预处理范畴(柯理化函数思想),在IE低版本浏览器中不兼容</li>
<li>call(null/undefined/不传参):在非严格模式下this都指向window,严格模式下,写的是谁this就是谁,不写this是undefined</li>
<li>一些需要特殊记忆的<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//this:window</span></div><div class="line">&#125;,<span class="number">1000</span>);</div><div class="line">ary.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</div><div class="line">    <span class="comment">//this:window</span></div><div class="line">    <span class="keyword">return</span> a-b</div><div class="line">&#125;);</div><div class="line">ary.forEach(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//this:window</span></div><div class="line">&#125;)</div><div class="line">ary.forEach(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//this:obj 数组中的方法,forEach/map第二个参数传递的是啥,相当于让匿名函数中的this指向啥,但是sort方法没有这个机制</span></div><div class="line">&#125;,obj)</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="面向对象-OOP-Object-Oriennted-Programming"><a href="#面向对象-OOP-Object-Oriennted-Programming" class="headerlink" title="面向对象(OOP: Object Oriennted Programming)"></a>面向对象(OOP: Object Oriennted Programming)</h3><blockquote>
<p>你是如何理解编程语言中的面向对象?</p>
<p>我们研究JS和使用JS编程本身就是基于面向对象的思想来开发的,JS中的一切内容都可以统称为要研究的”对象”,我们按照功能特点把所有内容划分成”几个大类,还可以基于大类划分小类”,我们开发研究的时候拿出类中的一个具体的事物”类的实例”来操作,当前实例具备的一些特点,同属于当前类的其他实例也具备这些特点:我们还要研究关于类的”封装,继承,多态”,这样有助于我们的编程开发</p>
</blockquote>
<ul>
<li>JS中的类:内置类,自定义类<ul>
<li>Function:所有的函数数据类型都是它的一个实例,普通函数,类(自定义的类,内置的一些类)这些都是函数数据类型的</li>
<li>Object:对象类,所有的对象数据类型(普通对象{},数组[],正则/^$/,Math对象,日期对象,类的实例,类.prototype,普通函数)都是它的一个实例: Object是一个大类,也是基类,下面可以划分很多的小类:<ul>
<li>Array</li>
<li>RegExp</li>
<li>Date</li>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>EventTarget<ul>
<li>Node<ul>
<li>Element<ul>
<li>HTMLElement<ul>
<li>HTMLDivElement</li>
<li>HTMLParagraphElement</li>
<li>HTMLAnchorElement</li>
<li>HTMLImageElement</li>
</ul>
</li>
</ul>
</li>
<li>Text</li>
<li>Comment</li>
<li>Document</li>
</ul>
</li>
</ul>
</li>
<li>HTMLCollection: 通过getElementsByTagName/ClassName/等获取的元素集合就是它的一个实例</li>
<li>NodeList:通过getElementsByName和childNodes等获取的节点集合都是它的一个实例</li>
<li>…</li>
</ul>
</li>
</ul>
</li>
<li><p>面向对象中的实例和类的关系,实例除了可以调取自己的私有属性方法使用之外,还可以调取自己隶属于原型上的公共方法:一个类可以创造很多很多的实例,不同实例之间即具备独立性也具备共同性</p>
<ul>
<li><p>画图:Array的原型图<br>  <img src="http://note.youdao.com/yws/public/resource/282d0a3e262b821e21367f4edd8982f6/xmlnote/4353C790A2D24D9F84C002A75F39E9A4/5262" alt="image"></p>
<ul>
<li>类原型上的属性和方法,相当于实例来说是公有的属性方法,但是相对于原型本身来说,这些属性方法是自己私有的</li>
<li><p>Object的prototype是不存在<strong>proto</strong>属性的,因为会执行它自己<br><img src="http://note.youdao.com/yws/public/resource/282d0a3e262b821e21367f4edd8982f6/xmlnote/901A6CA333AA43EAA84CDD3AEFBE4FBB/5204" alt="image"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//-&gt;在内置类的原型上扩展一个方法:</span></div><div class="line">hasPubProperty.检测某一个属性是否属于当前对象的公有属性</div><div class="line"><span class="built_in">Object</span>.prototype.hasPubProperty=<span class="function"><span class="keyword">function</span> <span class="title">hasPubProperty</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//-&gt;this:我们当前操作的一个实例</span></div><div class="line"><span class="meta">    "use strict"</span>;</div><div class="line">    <span class="keyword">var</span> attr=<span class="built_in">arguments</span>[<span class="number">0</span>];</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> attr===<span class="string">"undefined"</span>)&#123;</div><div class="line">        <span class="comment">//-&gt;throw new Error("parameter error");                 </span></div><div class="line">        <span class="comment">//Error:ReferenceError/TypeError/RangeError/SyntaxError...</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> (attr <span class="keyword">in</span> <span class="keyword">this</span>) &amp;&amp; <span class="keyword">this</span>.hasOwnProperty(attr)===<span class="literal">false</span></div><div class="line">&#125;</div><div class="line">obj.hasOwnProperty(<span class="string">"name"</span>);</div><div class="line">obj.hasPubProperty(<span class="string">"name"</span>);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>创建数据的方式有两种<ul>
<li>字面量方式创建</li>
<li>实例创建(构造函数创建)</li>
<li>链式写法:执行当前方法返回的结果依然是当前类的一个实例.这样就可以继续调取当前类原型上的其它方法执行了</li>
<li>对于引用数据类型来说,除了一些操作的语法不太一样以外,没有本质的区别:但是对于基本数据类型来说,还是存在很大的区别的</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/06/11/预解释&闭包&THIS&面向对象/" data-id="cj3ubyh1c000cewufii344f17" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-DOM回流和重绘&amp;DOM映射" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/11/DOM回流和重绘&DOM映射/" class="article-date">
  <time datetime="2017-06-11T12:38:08.061Z" itemprop="datePublished">2017-06-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/11/DOM回流和重绘&DOM映射/">DOM回流和重绘&amp;DOM映射</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="DOM回流和重绘"><a href="#DOM回流和重绘" class="headerlink" title="DOM回流和重绘"></a>DOM回流和重绘</h2><ul>
<li>每一次DOM操作都会引起回流和重绘<ul>
<li>DOM回流:在js中操作DOM,DOM节点发生改变(增,删,改)都会引发浏览器渲染DOM节点,找到修改的地方,这就是DOM回流</li>
<li>DOM重绘:把修改的内容添加到DOM节点里面,这就会引发DOM的重绘</li>
</ul>
</li>
<li>动态创建DOM结构然后添加到页面</li>
<li>动态创建Element标签<ul>
<li>document.createElement(“li”);///动态创建对象</li>
<li>oli.innerHTML=JSONstr;///给空对象里面绑定JSON数据</li>
<li>box.appendChild(oli);///将节点添加到DOM中</li>
</ul>
</li>
<li>字符串拼接<ul>
<li>var str=””///拼接内容</li>
<li>box.innerHTML+=str//将拼接的内容添加到DOM节点中,会将原有的DOM节点内的HTML结构重置,绑定的js事件全部取消<ul>
<li>innerHTML会创建新的DOM树,然后用这个DOM树完全替换调用元素的所有子节点,绑定在原有DOM树上的JS事件不会被绑在新的DOM树上</li>
<li>如果要保留新增节点绑定的js事件,可以将事件以内联式写入节点当中,创建新的DOM树时,会将内联式中的代码一起新建</li>
<li>innerHTML获取的是字符串,不是DOM对象,innerHTML只是DOM对象的一个属性,属性值保存的是DOM对象的字符串类型HTML结构,因为浏览器能解析字符串,更能解析JS-DOM节点,所以都能在页面上看到效果,但是两者的表现本质不同</li>
</ul>
</li>
<li>优点:减少了DOM回流和重绘的次数</li>
<li>缺点:之前DOM节点绑定的js事件都取消了,字符串拼接比较繁琐</li>
</ul>
</li>
<li>创建文档碎片(文档碎片:就是把所有动态创建的DOM节点放在一起的盒子),再一次性的添加到页面中<ul>
<li>document.createDocumentFragment();///先创建一个盒子,文档碎片</li>
<li>将要添加的内容全部添加到Fragment中</li>
<li>box.appendChild(frag);///将fragment一次性添加到DOM节点中</li>
<li>优点:只会引发一次DOM回流和重绘</li>
</ul>
</li>
</ul>
<h2 id="DOM映射"><a href="#DOM映射" class="headerlink" title="DOM映射"></a>DOM映射</h2><ul>
<li>html结构发生改变,监听他结构JS对象也会发生改变<ul>
<li>var oLis=oDiv.getElementsByClassName(“li”);</li>
<li>当oDiv中的li数量改变时,oLis也会随之改变,这是一个动态监听的过程,不是一次性的赋值</li>
</ul>
</li>
<li>类数组转化为数组<ul>
<li>var oLis=document.getElementsByClassName(“item”);</li>
<li>调用转化函数(自己写的)转化成为数组</li>
</ul>
</li>
<li>sort排序<ul>
<li>回调函数:parseFloat(a.innerHTML) - parseFloat(b.innerHTML)对数组重排序  </li>
</ul>
</li>
<li>DOM操作<ul>
<li>使用文档碎片方法一次性修改DOM父节点</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/06/11/DOM回流和重绘&DOM映射/" data-id="cj3ubyh010001ewuf0eg3eyk4" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-类的多态&amp;函数的三面性&amp;改变THIS指向" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/11/类的多态&函数的三面性&改变THIS指向/" class="article-date">
  <time datetime="2017-06-11T12:37:32.507Z" itemprop="datePublished">2017-06-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/11/类的多态&函数的三面性&改变THIS指向/">类的多态&amp;函数的三面性&amp;改变THIS指向</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="类的多态"><a href="#类的多态" class="headerlink" title="类的多态"></a>类的多态</h2><ul>
<li>JS中不存在严格意义上的多态,不存在重载</li>
<li>只存在重写,可以使用重写的形式实现重载</li>
<li>通过重写实现重载,根据实参返回不同函数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>.length==<span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>.length==<span class="number">2</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="number">2</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> num=sum(<span class="number">1</span>,<span class="number">2</span>)();</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="函数的三面性"><a href="#函数的三面性" class="headerlink" title="函数的三面性"></a>函数的三面性</h2><ol>
<li>普通函数方法<ul>
<li>函数执行的时候开辟栈内存作用域,形成闭包,进行预解释 </li>
</ul>
</li>
<li>类<ul>
<li>他可以创建自己的实例,也可以在prototype属性上保存自己的属性和方法</li>
</ul>
</li>
<li>普通对象<ul>
<li>像object一样,拥有引用空间堆内存,也有<strong>proto</strong>找到自己所属的类的原型</li>
</ul>
</li>
</ol>
<h2 id="改变this指向"><a href="#改变this指向" class="headerlink" title="改变this指向"></a>改变this指向</h2><ul>
<li><p>求数组最大值</p>
<ul>
<li>apply改变this指向之前,会让他前面调用函数执行,并把参数参进去<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>,[<span class="number">1</span>,<span class="number">23</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>])</div><div class="line"><span class="comment">//上式==Math.max([1,23,4,5,6,1]),apply到null上</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>bind也是改变调用对象对的this指向,但是改变的时候,没有让调用对象执行,只是bing函数执行完,改变完调用对象的this后,将改变this后的调用对象方法,返回</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num= myName.bind(obj);</div><div class="line">num(<span class="string">"耐克"</span>,<span class="string">"阿迪"</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>call();call(null);call(undefined)</p>
<ul>
<li>this均指向window</li>
<li>严格模式下,没有函数没有调用对象,函数的this就是window,严格模式下的函数没有调用对象,this就指向undefined,null指向null</li>
</ul>
</li>
<li><p>eval()</p>
<ul>
<li>将字符串转化成js表达式</li>
<li>如果要输入变量,需要使用双引号把括号包起来<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">eval</span>(<span class="string">"var a=0"</span>);</div><div class="line"><span class="built_in">eval</span>(<span class="string">"("</span>+obj+<span class="string">")"</span>);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>(fn1,fn2,obj.fn)()</p>
<ul>
<li>相当于自执行函数,但是执行的是最后一个函数,this指向window</li>
</ul>
</li>
</ul>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><ul>
<li>JSON数据类型和对象数据类型和数组很相似</li>
<li>标准JSON数据格式<ul>
<li>将对象属性名都用字符串包含起来</li>
</ul>
</li>
<li><p>JSON对象和JSON字符串两者是可以互相转化的</p>
<ul>
<li>obj是一个JSON对象</li>
<li>obj3是一个JSON字符串,最外面用’’单引号,里面用双引号””,也就是属性名必须用双引号包起来</li>
<li>JSON.stringify<ul>
<li>将JSON对象转化成JSON字符串</li>
</ul>
</li>
<li>JSON.parse<ul>
<li>将JSON字符串转化成JSON对象<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj=&#123;</div><div class="line">    <span class="string">"name"</span>:<span class="string">"abc"</span>,</div><div class="line">    <span class="string">"age"</span>:<span class="number">1</span>,</div><div class="line">    <span class="string">"method"</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> obj3=<span class="string">'&#123;"name":"abc","age":1,"method":[1,2,3,4]&#125;'</span>;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>在IE6-7中不兼容JSON</p>
<ul>
<li>使用eval()来兼容<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">JSONTrans</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.JSON)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(obj);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">eval</span>(<span class="string">'('</span>+obj+<span class="string">')'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>捕获报错信息</p>
<ul>
<li>try{}catch(){}finally{}<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    statement</div><div class="line">&#125;<span class="keyword">catch</span>(e)&#123;<span class="comment">//储存的是报错的信息,必须要写</span></div><div class="line">    <span class="built_in">console</span>.log(e)<span class="comment">//把statement报错的信息打印在控制台中</span></div><div class="line">    <span class="built_in">console</span>.log(e.name)<span class="comment">// </span></div><div class="line">    <span class="built_in">console</span>.log(e.message)<span class="comment">// </span></div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"这里可以随意填写,会改变报错的内容"</span>)</div><div class="line">&#125;<span class="keyword">finally</span>&#123;<span class="comment">//不管你报不报错,finally都执行,一般不使用</span></div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h2><ul>
<li>类数组和数组是不同的类</li>
<li>newA2<ol>
<li>采用数组中的slice方法</li>
<li>使用call改变方法的this</li>
<li>最后形成n.slice();<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a=<span class="built_in">document</span>.getElementsByTagName(<span class="string">"div"</span>);</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> newA=<span class="built_in">Array</span>.apply(<span class="literal">null</span>,n);  <span class="comment">//将类数组转化成数组</span></div><div class="line">        <span class="keyword">var</span> newA2=[].slice.call(n);     <span class="comment">//和上式作用相同</span></div><div class="line">        <span class="keyword">return</span> newA;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><ul>
<li>把一个函数A当作实参,传递个给函数B,在B执行的时候,A再执行</li>
<li>localeCompare</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/06/11/类的多态&函数的三面性&改变THIS指向/" data-id="cj3ubyh0h0006ewuftec2390p" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-类的封装&amp;类的继承" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/11/类的封装&类的继承/" class="article-date">
  <time datetime="2017-06-11T12:36:40.028Z" itemprop="datePublished">2017-06-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/11/类的封装&类的继承/">类的封装&amp;类的继承</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="类的封装"><a href="#类的封装" class="headerlink" title="类的封装"></a>类的封装</h2><ul>
<li><p>工厂模式</p>
<ul>
<li>其实就是函数的封装</li>
<li>就是根据不同实参,返回不同的结果<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">self</span>(<span class="params">num1,num2,num3</span>)</span>&#123;</div><div class="line">   <span class="keyword">var</span> per:&#123;&#125;;</div><div class="line">   <span class="keyword">if</span>(sex==<span class="string">"man"</span>)&#123;</div><div class="line">       retrun person.job=<span class="string">"soldier"</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span>(sex=<span class="string">"girl"</span>)&#123;</div><div class="line">       <span class="keyword">return</span> person.job=<span class="string">"teacher"</span></div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(self(<span class="string">"zhao"</span>,<span class="string">"18"</span>,<span class="string">"girl"</span>))</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>构造函数模式</p>
<ul>
<li>类:具有相同属性和方法的实例的一个集合总称<ul>
<li>Number,String,Boolean,Null,Undefined,Object,Function,Date,Math,RegExp,Array<ul>
<li>通过构造函数的形式,创建了一个Number这个类的一个实例</li>
<li>构造函数创建实例的方式,通过本身的运算,返回一个引用实例</li>
</ul>
</li>
<li>自定义类,自定义构造函数<ul>
<li>自定义构造函数的名字,首字母必须大写(规范)</li>
<li>使用this给实例创建私有属性</li>
<li>所有的new或者字面量形式创建的对象都会继承他所属类存储在原型链上的的私有和公有属性和方法),所属类的其他私有属性和方法不会被其实例继承<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="keyword">this</span>.age=<span class="string">"6666"</span>;</div><div class="line">Person.hobby=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"aaaa"</span>)</div><div class="line">&#125;;</div><div class="line">Person.prototype.food=<span class="string">"haha"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a=<span class="keyword">new</span> Person();</div><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line"><span class="built_in">console</span>.log(a.age);</div><div class="line"><span class="built_in">console</span>.log(a.food);</div><div class="line"><span class="built_in">console</span>.log(a.hobby);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>原型链</p>
<ul>
<li><strong>proto</strong>原型,所有引用类型都存在这个不可枚举的属性,指向所属类的原型</li>
<li>constructor 原型对象的属性,指向构造函数,不可枚举</li>
<li>prototype 函数的不可枚举属性,原型规范(保存的是函数的公有方法),所有的函数和构造函数; <ul>
<li>函数才拥有这个属性prototype</li>
<li>prototype是一个引用地址,浏览器禁止修改内置类</li>
</ul>
</li>
<li>原型链查找<ul>
<li>查找属性时,如果当前实例私有的属性不存在要查找的属性,会到当前实例所属类的原型上去找公有的属性</li>
<li>for in<ul>
<li>将私有的和原型上公有的可枚举的都遍历出来</li>
</ul>
</li>
<li>hasOwnProperty<ul>
<li>检测是否为私有属性,原型上的是公有的所以检测不到返回false</li>
</ul>
</li>
</ul>
</li>
<li>定义公有方法<ol>
<li>找出他当前所属类</li>
<li>在当前类的公有原型prototype定义公有方法</li>
<li>子类直接调用 — 构造函数中的this,当前创建的实例</li>
</ol>
</li>
</ul>
</li>
<li><p>call 和 apply</p>
<ul>
<li>作用:改变this的指向</li>
<li>传参数: 第一个参数改变调用对象中this指向,第一参数是谁,this就指向谁</li>
<li>后边的参数: 是对应调用对象,传的实参 <ul>
<li>call是一个个传进去的 </li>
<li>apply 以数组的形式穿进去的</li>
</ul>
</li>
<li>call和apply执行: 先让调用对象执行,然后再改变this,并且传值进去</li>
</ul>
</li>
</ul>
<h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><ul>
<li>原型继承:有A类与B类,想让A拥有B中的方法,使用原型继承,使他们的原型直接存在联系<ul>
<li>让A的原型=B的一个实例,手动添加constructor</li>
<li>在ECMAScript 6中,使用Object.assign,可以将B的原型复制到A的原型中,使得A的实例可以同时使用A,B两类的公有方法</li>
</ul>
</li>
<li><p>call继承</p>
<ul>
<li>把父类(A)设置私有的属性,克隆一份作为子类(B)私有的属性<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.x = <span class="number">100</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">D</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    A.call(<span class="keyword">this</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> D();</div><div class="line"><span class="built_in">console</span>.log(o);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>冒充对象继承</p>
<ul>
<li>子类继承了父类私有的和公有的属性和方法<pre><code class="JavaScript">  <span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>{
  <span class="keyword">this</span>.x = <span class="number">100</span>;
}
A.prototype.getX = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
  <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)
};
<span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>{
  <span class="keyword">var</span> temp = <span class="keyword">new</span> A();
  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> temp) {
      <span class="keyword">this</span>[key] = temp[key];
  }
}
<span class="keyword">var</span> b = <span class="keyword">new</span> B();
</code></pre>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/06/11/类的封装&类的继承/" data-id="cj3ubyh0w0008ewuf5ih29e3n" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-逻辑运算优先级&amp;类的封装" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/11/逻辑运算优先级&类的封装/" class="article-date">
  <time datetime="2017-06-11T12:34:30.831Z" itemprop="datePublished">2017-06-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/11/逻辑运算优先级&类的封装/">逻辑运算优先级&amp;类的封装</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="逻辑运算优先级"><a href="#逻辑运算优先级" class="headerlink" title="逻辑运算优先级"></a>逻辑运算优先级</h2><p>优先级</p>
<ul>
<li>19<ul>
<li>()运算优先级最高</li>
</ul>
</li>
<li>18<ul>
<li>成员访问:访问对象的属性</li>
</ul>
</li>
<li>17<ul>
<li>函数的调用</li>
</ul>
</li>
<li>15 (从右到左执行)<ul>
<li>逻辑非        ! …</li>
<li>一元加法    + …</li>
<li>一元减法        - …</li>
<li>前置递增        ++ …</li>
<li>前置递减        – …</li>
<li>typeof        typeof …</li>
<li>void        void …</li>
<li>delete    delete …</li>
</ul>
</li>
<li>14 <ul>
<li>乘法        … * …<br>除法    … / …<br>取模        … % …</li>
</ul>
</li>
<li>13 <ul>
<li>加法    … + …</li>
<li>减法        … - …</li>
</ul>
</li>
<li>12<br>  -按位左移        … &lt;&lt; …</li>
<li>11 <ul>
<li>小于        … &lt; …<br>小于等于        … &lt;= …<br>大于        … &gt; …<br>大于等于        … &gt;= …<br>in        … in …<br>instanceof        … instanceof …</li>
</ul>
</li>
<li>10 <ul>
<li>等号        … == …</li>
<li>非等号        … != …</li>
<li>全等号        … === …</li>
<li>非全等号        … !== …</li>
</ul>
</li>
<li>9<ul>
<li>按位与    … &amp; …</li>
</ul>
</li>
<li>8<ul>
<li>按位异或        … ^ …</li>
</ul>
</li>
<li>7<ul>
<li>按位或        … | …</li>
</ul>
</li>
<li>6<ul>
<li>逻辑与        … &amp;&amp; …</li>
</ul>
</li>
<li>5<ul>
<li>逻辑或        … || …</li>
</ul>
</li>
<li>4 (从右到左执行)<ul>
<li>条件运算符        … ? … : …</li>
</ul>
</li>
<li>3 (从右到左执行)<ul>
<li>赋值        … = …</li>
<li>复合赋值</li>
</ul>
</li>
<li>总结<ol>
<li>赋值操作排在所有的比较最后，（num == 1）里的内用最优先运算。</li>
<li>成员访问的优先级在，（）运算之后，在其他的运算之前。</li>
<li>函数的执行，在其他比较和运算符之前之前。</li>
<li>判断的优先级也在赋值 = 号的最前边。</li>
<li>逻辑与 和 逻辑或 要在左右两边的运算完成以后，在进行 逻辑与  和 逻辑或 比较。</li>
</ol>
</li>
</ul>
<h2 id="几大知识点"><a href="#几大知识点" class="headerlink" title="几大知识点"></a>几大知识点</h2><ol>
<li><p>面向对象</p>
<ul>
<li>在js中可以把任意的引用和变量都看成一个对象</li>
<li>主要表现形式(三种)<ul>
<li>类的封装</li>
<li>类的继承</li>
<li>类的多态</li>
</ul>
</li>
</ul>
</li>
<li><p>DOM事件</p>
</li>
<li><p>异步交互ajax</p>
</li>
</ol>
<h2 id="类的封装"><a href="#类的封装" class="headerlink" title="类的封装"></a>类的封装</h2><ul>
<li><p>单例模式</p>
<ul>
<li><p>将方法,定义在一个对象的属性上,这样我们就避免了全局变量的污染</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"oo"</span>,</div><div class="line">    <span class="attr">age</span>: <span class="number">12</span>,</div><div class="line">    <span class="attr">method</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> objName;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">ale</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.num = that.age;</div><div class="line">            <span class="keyword">return</span> num1 + <span class="keyword">this</span>.num + num2;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>))</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在代码加载的时候,避免了全局栈内存的消耗</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">var</span> main = &#123;</div><div class="line">    <span class="attr">init</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.changeName();</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">changeName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line">        <span class="keyword">var</span> obody = <span class="built_in">document</span>.body;</div><div class="line">        obody.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            that.changeValue();</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">changeValue</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">document</span>.getElementById(<span class="string">"one"</span>).value = <span class="string">"字符串"</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">main.init();</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/06/11/逻辑运算优先级&类的封装/" data-id="cj3ubyh0w000aewuf01qgr2v4" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-逻辑与与或&amp;arguments" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/11/逻辑与与或&arguments/" class="article-date">
  <time datetime="2017-06-11T12:32:47.545Z" itemprop="datePublished">2017-06-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/11/逻辑与与或&arguments/">逻辑与与或&amp;arguments</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><p>数组的维度</p>
<ul>
<li>一维数组:[12,23,”珠峰”,true…] 数组中的每一项都是基本数据类型</li>
<li>二维数组:[12,[name:”珠峰”],[23,24]    </li>
<li>多维数组:[12,{friend:[34,45]}]</li>
</ul>
</li>
<li><p>数组排序</p>
<ul>
<li>ary.sort()</li>
<li>ary.sort(function(a,b){return a-b})</li>
</ul>
</li>
<li><p>删除数组最后一项</p>
<ul>
<li>ary.pop()</li>
<li>ary.length–</li>
<li>ary.splice(ary.length-1,1)</li>
</ul>
</li>
<li><p>找出第n项到第m项</p>
<ul>
<li>ary.slice(n-1,m)</li>
</ul>
</li>
<li><p>当前页面一屏幕的宽度</p>
<ul>
<li>document.documentElement.clientWidth||document.body.clientWidth</li>
</ul>
</li>
<li><p>$</p>
<ul>
<li>ul&gt;li{$}*9 [tab] 创建九个li,每个li中的内容是从1-9累加的数字</li>
</ul>
</li>
<li><p>Math</p>
<ul>
<li>abs</li>
<li>ceil</li>
<li>floor</li>
<li>max</li>
<li>min</li>
<li>round </li>
<li>random</li>
<li>sqrt 开平方(SQuare RooT) Math.sqrt(100)-&gt;10</li>
<li>pow  求幂  Math.pow(10,3)-&gt;1000</li>
<li>PI 圆周率</li>
</ul>
</li>
<li><p>两个值进行比较,如果数据类型不一样的话,会进行默认的数据类型转换</p>
<ul>
<li>对象 == 对象:比较的是各自代表的内存地址,地址相同则相等,地址不同则不相等</li>
<li>对象 == 数字:先把对象toStirng,然后把结果再Number,最后和数字比较</li>
<li>对象 == 字符串:先把对象toString,然后在比较</li>
<li>对象 == 布尔:都转换成数字<ul>
<li>[] ==false =&gt;[].toString() -&gt; “” -&gt;Number(“”) -&gt; 0</li>
<li>false -&gt; 0 true -&gt;1</li>
<li>0 == 0 =&gt;true</li>
</ul>
</li>
<li>字符串 == 数字: 字符串转换成数字</li>
<li>字符串==布尔:都转换成数字</li>
<li>布尔==数字:布尔转换成数字</li>
<li>null==undefined是相等的,他们和自身也相等,除此之外和其他任何的值都不相等</li>
<li>NaN==NaN是不相等的</li>
<li>把一个值转换成布尔类型:!,!!,Boolean,if(num)条件的意思也是先把num转成布尔值沿着真假…<ul>
<li>只有0,NaN,空字符串,null,undefined,false代表false,其余都是true</li>
</ul>
</li>
<li>![] == false :==判断的优先级是最低的,他肯定是先把左右两边的表达式执行,执行的结果再进行比较<ul>
<li>![]转换成布尔再取反 -&gt;false</li>
<li>true</li>
</ul>
</li>
</ul>
</li>
<li><p>函数</p>
<ul>
<li>函数形参本身就是变量,而且是当前作用域的私有变量</li>
<li>函数执行传递进来的实参本身就是数据值</li>
</ul>
</li>
<li><p>引用数据类型赋值遵循三步操作</p>
<ul>
<li>首先开辟一个堆内存空间,浏览器会为其分配一个16进制的地址</li>
<li>把属性名和属性值分别储存在这个内存空间中(函数数据类型存储的是函数体中的”代码字符串”),此时的自执行函数无法读取obj的属性(因为obj此时还是undefined)</li>
<li>把堆内存的空间地址复制给对应的变量</li>
</ul>
</li>
</ul>
<h2 id="逻辑与和逻辑或"><a href="#逻辑与和逻辑或" class="headerlink" title="逻辑与和逻辑或"></a>逻辑与和逻辑或</h2><ul>
<li>|| 逻辑或</li>
<li>&amp;&amp; 逻辑与</li>
<li>应用<ol>
<li>判断的时候用<ul>
<li>if(A || B){}: 只要有一个为真,整体就是真 </li>
<li>IF(A &amp;&amp; B){}: 只要有两个都为真,整体才为真</li>
</ul>
</li>
<li>赋值的时候使用<ul>
<li>var num=3 || 0; </li>
<li>var num=3 &amp;&amp; 0;</li>
<li>逻辑或:首先看左边的值是真还是假(“除了五个都是真”),如果为真,返回左边值,如果为假,返回右边的值</li>
<li>逻辑与:和逻辑或相同,先看左边的值是真还是假,如果左边为真返回右边的值,左边为假返回左边的值</li>
</ul>
</li>
<li>在两者同时出现的时候,逻辑与的优先级高于逻辑或<ul>
<li>0 || 1 &amp;&amp; 2 || 3 -&gt;2</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><ul>
<li>在非严格模式下(正常写代码默认就是非严格模式),形参和arguments存在”映射”关系,一个值发生改变,另一个都会受到影响</li>
<li>arguments.length–对arguments无效,因为arguments是内置的类数值,length–只会把length属性的值改了,但是不会影响最后容器中的内容存储</li>
<li>arguments.callee: 当前函数本身</li>
<li>arguments.callee.caller: 存储的是当前函数执行所在的作用域,或者说在哪个函数下执行的,这个属性存储的就是哪个函数名(在window下执行的,存储的结果是null)</li>
<li>JS中的严格模式:对一些代码的要求比之前更加严格了,具体都有哪些变化(高程三最后专题总结的时候”JS严格和非严格模式的区别”)<ul>
<li>“use strict”–&gt;在编写代码之前声采用JS的严格模式:这种模式现在应用特别的多,基本上封装的组件类库都是采用这种模式</li>
<li>严格模式下,arguments和形参之间的”映射”关系中断了,而且禁止我们使用arguments.callee和arguments.caller两个属性</li>
</ul>
</li>
</ul>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><ul>
<li>this指的是当前函数执行的主体:谁来触发这个方法执行或者谁来操作这个方法,那么this就是谁</li>
<li>给元素绑定事件,当事件触发方法执行的时候,方法中的this是当前元素本身</li>
<li>函数执行,看函数前面是否有点,有的话,点前面是谁this就是谁,没有的话,this就是window</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">document</span>.body.onclick=<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    fn();<span class="comment">//这里面的this是window,因为fn()前面没有"."</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ul>
<li>获取下一个弟弟元素节点 next</li>
<li>获取所有的哥哥元素节点 prevAll</li>
<li>获取所有的弟弟元素节点 nextAll</li>
<li>获取所有的兄弟元素节点 siblings</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/06/11/逻辑与与或&arguments/" data-id="cj3ubyh0w0009ewufpuubabo3" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-闭包&amp;THIS" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/11/闭包&THIS/" class="article-date">
  <time datetime="2017-06-11T12:32:47.498Z" itemprop="datePublished">2017-06-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/11/闭包&THIS/">闭包&amp;THIS</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>严格意义上的闭包,严格闭包通过栈内存不销毁,保护内部变量,而且下一级作用域可以访问内部变量</li>
<li>更严格意义上的闭包,函数可以在父函数外面调用父函数作用域的值</li>
<li>在函数执行的时候,函数体中有返回值,函数执行的作用域不销毁</li>
<li>调用了上一级栈内存的变量,并返回给函数外,造成了上一级作用域不销毁(栈内存)</li>
<li>缺点<ul>
<li>会造成很多不销毁的栈内存,影响浏览器的性能</li>
</ul>
</li>
<li>优点<ul>
<li>保护内部变量不被外界所污染,内部变量也不污染外部变量</li>
<li>可以通过返回值访问内部变量的值</li>
</ul>
</li>
<li>销毁的作用域<ul>
<li>当函数执行完,如果没有返回值,供外面作用域调用则直接销毁</li>
<li>在函数内部的自执行函数,虽然调用了上级作用域的值,但是函数执行完作用域依然销毁</li>
<li>在我们的函数执行的返回值,紧跟着当前函数直接执行的时候,作用域也会销毁</li>
<li>产生第三方对函数内部变量有承接,赋值的时候,当前作用域不销毁,这种销毁时暂时不销毁</li>
<li>在绑定事件中的函数,函数的栈内存是永远不销毁的</li>
<li>函数和DOM形成映射,是操作DOM的时候方法,这时候的函数作用域是不销毁的</li>
</ul>
</li>
</ul>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><ul>
<li>this跟在哪的栈内存中执行的,跟那个堆内存中定义的,跟原型链,跟预解释一点关系都没有<ul>
<li>函数执行的时候,看函数前面有没有. 点前面是谁,this就是谁(调用对象),没有点就是window</li>
<li>自执行函数中的this永远是window</li>
<li>DOM事件当中,直接绑定的触发函数中的this是当前的DOM对象</li>
<li>构造函数中this指向当前类的实例</li>
</ul>
</li>
</ul>
<h2 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h2><ul>
<li>检测属性是否在对象中<ul>
<li>“属性名” in 对象返回布尔值</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/06/11/闭包&THIS/" data-id="cj3ubyh0w000bewufq2fcdp8a" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archieven</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recente berichten</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/06/12/关于vue/">跟vue有关</a>
          </li>
        
          <li>
            <a href="/2017/06/12/关于node/">关于node.js</a>
          </li>
        
          <li>
            <a href="/2017/06/12/不支持低版本浏览器搜集/">不支持的浏览器</a>
          </li>
        
          <li>
            <a href="/2017/06/11/预解释&闭包&THIS&面向对象/">预解释&amp;闭包&amp;THIS&amp;面向对象</a>
          </li>
        
          <li>
            <a href="/2017/06/11/DOM回流和重绘&DOM映射/">DOM回流和重绘&amp;DOM映射</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>